dat-class                package:TIMP                R Documentation

_C_l_a_s_s "_d_a_t" _f_o_r _m_o_d_e_l _a_n_d _d_a_t_a _s_t_o_r_a_g_e

_D_e_s_c_r_i_p_t_i_o_n:

     'dat' is the super-class of other classes representing models and
     data, so that other model/data classes (e.g., 'kin' and 'spec' 
     for kinetic and spectral models respectively) also have the slots
     defined here.  These slots may be specified in the '...'  argument
     of the  'initModel' function.

_O_b_j_e_c_t_s _f_r_o_m _t_h_e _C_l_a_s_s:

     Objects from the class  can be created by calls of the form
     'new("dat", ...)' or  'dat(...)', but  most are most often made by
     invoking another function such as  'readData' or 'initModel'.

_S_l_o_t_s:

     '_p_s_i._d_f': Object of class '"matrix"'  dataset from 1 experiment

     '_p_s_i._w_e_i_g_h_t': Object of class '"matrix"' weighted  dataset from 1
          experiment

     '_x': Object of class '"vector"' time or other independent
          variable.  

     '_n_t': Object of class '"integer"' length 'x'

     '_x_2': Object of class '"vector"'  vector of points in  2nd
          independent dimension, such as wavelengths of wavenumbers

     '_n_l': Object of class '"integer"'  length 'x2' 

     '_C_2': Object of class '"matrix"' concentration matrix for
          simulated data

     '_E_2': Object of class '"matrix"' matrix of spectra for simulated
          data

     '_s_i_g_m_a': Object of class '"numeric"' noise level in  simulated
          data 

     '_m_o_d__t_y_p_e': Object of class '"character"' character string
          defining the model type, e.g.,  '"kin"' or '"spec"'

     '_p_a_r_n_a_m_e_s': Object of class '"vector"' vector of parameter names,
          used internally

     '_f_i_n_i_s_h_e_d': Object of class '"logical"' describes  whether
          optimization is complete

     '_s_i_m_d_a_t_a': Object of class '"logical"'  logical that is 'TRUE' if
          the data is simulated,  'FALSE' otherwise; will determine
          whether values in 'C2' and  'E2' are plotted with results

     '_w_e_i_g_h_t_p_a_r': Object of class '"list"'  list of vectors 
          'c(first_x, last_x, first_x2, last_x2, weight)',  where each
          vector is of length 5 and  specifies an interval in which to
          weight the data.  

        _f_i_r_s_t__x first(absolute, not an index) 'x' to weight

        _l_a_s_t__x last (absolute, not an index) 'x' to weight 

        _f_i_r_s_t__x_2 first (absolute, not an index)  'x2' to weight

        _l_a_s_t__x_2 last (absolute, not an index)  'x2' to weight 

        _w_e_i_g_h_t numeric by which to weight data 

          Note that if vector elements 1-4 are 'NA' (not a number), the
          firstmost  point of the data is taken for elements 1 and 3,
          and the lastmost points are taken for 2 and 4.  For example,
          ' weight_par = list(c(40, 1500, 400, 600, .9),  c(NA, NA,
          700, 800, .1))'  will weight data between times 40 and 1500 
          picoseconds and 700 and 800 wavelengths by .9, and will
          weight data at  all times between wavelength 700 and 800 by
          .1.   Note also that for single photon counting data 
          'weightpar = list(poisson = TRUE)' will apply poisson
          weighting to all  non-zero elements of the data. 

     '_w_e_i_g_h_t': Object of class '"logical"' 'TRUE' when the
          specification in  'weightpar' is to be applied and 'FALSE'
          otherwise

     '_w_e_i_g_h_t_M': Object of class '"matrix"' weights 

     '_w_e_i_g_h_t_s_m_o_o_t_h': Object of class '"list"' type of smoothing to
          apply with weighting; not currently used

     '_f_i_x_e_d': Object of class '"list"' list of lists or vectors giving
          the parameter values  to fix (at their starting values)
          during optimization. 

     '_c_l_p_0': Object of class '"list"'  list of lists with elements
          'low', 'high' and  'comp', specifying the least value in 
          'x2' to constrain  to zero, the greatest value in  'x2' to 
          constrain to zero, and the component to which to apply the
          zero constraint,  respectively.  e.g., 'clp0 =
          list(list(low=400, high = 600, comp=2),  list(low = 600, high
          = 650, comp=4))' applies zero constraints to the spectra 
          associated with components 2 and 4. 

     '_m_a_k_e_p_s': Object of class '"character"'  specifyies the prefix of
          files written to  postscript

     '_c_l_p_e_q_u_s_p_e_c': Object of class '"list"' list of lists each of which
          has elements 'to,  from, low, high', and optional element
          'dataset' to specify the dataset from which to get the
          reference clp (that is, a spectrum for kinetic  models). 
          'to' is the component to be fixed in relation to some other 
          component; from is the reference component.  'low' and 'high'
           are the  least and greatest absolute values of the 'clp'
          vector to constrain.  e.g.,  'clpequspec = list(list(low =
          400, high = 600, to = 1, from = 2))'  will constrain the
          first component to equality to the second component  between
          wavelengths 400 and 600.  Note that equality constraints are
          actually constraints to a linear relationship.  For each of
          the equality constraints specfied as a list in the
          'clpequspec' list, specify a starting value parameterizing
          this linear relation in the vector 'clpequ'; if true equality
          is desired then fix the corresponding parameter in 'clpequ'
          to 1.  Note that if multiple components are constraints, the
          'from' in the sublists should be increasing order,  (i.e.,
          '(list(to=2, from=1, low=100, high=10000),  list(to=3,
          from=1, low=10000, high=100))', not 'list(to=3, from=1,
          low=10000, high=100),  list(to=2, from=1, low=10000,
          high=100)')

     '_l_c_l_p_0': Object of class '"logical"' 'TRUE' if specification in
          'clp0'  is to be applied and 'FALSE' otherwise 

     '_l_c_l_p_e_q_u': Object of class '"logical"' 'TRUE' if specification in
          clpequspec  is to be applied and 'FALSE' otherwise

     '_t_i_t_l_e': Object of class '"character"' displayed on output plots

     '_m_h_i_s_t': Object of class '"list"'  list describing fitting history

     '_d_a_t_C_a_l_l': Object of class '"list"' list of calls to functions

     _d_r_e_l vector of starting parameters for dataset scaling relations

     '_d_s_c_a_l_s_p_e_c': Object of class '"list"' 

     '_d_r_e_l': Object of class '"vector"'  vector of starting parameters
          for dataset scaling relations

     '_c_l_p_e_q_u': Object of class '"vector"'  describes the parameters
          governing the clp equality constraints specified in
          'clpequspec'

     '_s_c_a_l_x': Object of class '"numeric"'  numeric by which to scale
          the 'x' axis in plotting

     _p_r_e_l vector of starting values for the relations described in 
          prelspec

     '_p_r_e_l': Object of class '"vector"'  vector of starting values for
          the relations described in  prelspec

     '_p_r_e_l_s_p_e_c': Object of class '"list"'  list of lists to specify the
          functional relationship between parameters, each of which has
          elements 

        _w_h_a_t_1 character string describing the parameter type to relate,
              e.g., '"kinpar"' 

        _w_h_a_t_2 the parameter type on which the relation is based;
             usually  the same as 'what1'

        _i_n_d_1 index into 'what1'

        _i_n_d_2 index into 'what2'

        _r_e_l character string,  optional argument to specify functional
             relation type,  by default linear  .in -3

             e.g.,  'prelspec = list(list(what1 = "kinpar", what2 =
             "kinpar", ind1 = 1,  ind2 = 5))'  relates the 1st element
             of 'kinpar' to the 5th element of  'kinpar'.  The starting
             values parameterizing the relationship are  given in the
             'prel' vector

        '_f_v_e_c_i_n_d': Object of class '"vector"'  vector containing
             indices of fixed parameters 

        '_p_v_e_c_i_n_d': Object of class '"vector"'  used internally to store
             indices of related parameters. 

        '_g_r_o_u_p_s': Object of class '"list"'  list containing lists of
             pairs c(x2 index, dataset index).  the 'x2' values (which
             are solved for as conditionally linear  parameters) are
             equated for all pairs in a list.

        '_i_t_e_r': Object of class '"numeric"'  describing the  number of
             iterations that is run; this is sometimes  stored after
             fitting, but has not effect as an argument to  
             'initModel'

        '_c_l_p_C_o_n': Object of class '"list"'  used internally to enforce
             constraints on the clp

        '_n_c_o_m_p': Object of class '"numeric"'  describing the number of
             components in a model

        '_c_l_p_d_e_p': Object of class '"logical"'  describing whether a
             model is dependent on the index of 'x2'

        '_i_n_t_e_n': Object of class '"matrix"'  for use with FLIM data;
             represents the number of photons per pixel measured over
             the course of all  times $t$ represented by the dataset. 
             See the help for the 'readData' function for more
             information. 

        '_p_o_s_i_t_i_v_e_p_a_r': Object of class '"vector"'  containing character
             strings of those parameter vectors to constrain to
             positivity, e.g., 'positivepar=c("kinpar")'

_A_u_t_h_o_r(_s):

     Katharine M. Mullen, Ivo H. M. van Stokkum

_S_e_e _A_l_s_o:

     'kin-class', 'spec-class'

_E_x_a_m_p_l_e_s:

     # simulate data 

      C <- matrix(nrow = 51, ncol = 2)
      k <- c(.5, 1)
      t <- seq(0, 2, by = 2/50)
      C[, 1] <- exp( - k[1] * t)
      C[, 2] <- exp( - k[2] * t) 
      E <- matrix(nrow = 51, ncol = 2)
      wavenum <- seq(18000, 28000, by=200)
      location <- c(25000, 20000)
      delta <- c(5000, 7000)
      amp <- c(1, 2)
      E[, 1] <- amp[1] * exp( - log(2) * (2 * (wavenum - location[1])/delta[1])^2)
      E[, 2] <- amp[2] * exp( - log(2) * (2 * (wavenum - location[2])/delta[2])^2)
      sigma <- .001
      Psi_q  <- C 

      # initialize an object of class dat 
      Psi_q_data <- dat(psi.df = Psi_q, x = t, nt = length(t), 
      x2 = wavenum, nl = length(wavenum))

      # initialize an object of class dat via initModel 
      # this dat object is also a kin object
      kinetic_model <- initModel(mod_type = "kin", seqmod = FALSE, 
      kinpar = c(.1, 2))

